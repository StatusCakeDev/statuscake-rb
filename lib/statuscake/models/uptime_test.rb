# frozen_string_literal: true

# StatusCake API
#
# Copyright (c) 2022
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
# API version: 1.0.1
# Contact: support@statuscake.com
#
# Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

require 'date'
require 'time'

module StatusCake
  # :nodoc
  class UptimeTest
    # Uptime check ID
    attr_accessor :id

    # Name of the check
    attr_accessor :name

    attr_accessor :test_type

    # URL, FQDN, or IP address of the server under test
    attr_accessor :website_url

    attr_accessor :check_rate

    # Number of confirmation servers to confirm downtime before an alert is triggered
    attr_accessor :confirmation

    # List of contact group IDs
    attr_accessor :contact_groups

    # JSON object. Represents headers to be sent when making requests
    attr_accessor :custom_header

    # List of IP addresses to compare against returned DNS records
    attr_accessor :dns_ips

    # FQDN or IP address of the nameserver to query
    attr_accessor :dns_server

    # Whether to consider the check as down if the content is present within the response
    attr_accessor :do_not_find

    # Whether to send an alert if the SSL certificate is soon to expire
    attr_accessor :enable_ssl_alert

    # Specify where the redirect chain should end
    attr_accessor :final_endpoint

    # String to look for within the response. Considered down if not found
    attr_accessor :find_string

    # Whether to follow redirects when testing. Disabled by default
    attr_accessor :follow_redirects

    # Include header content in string match search
    attr_accessor :include_header

    # Name of the hosting provider
    attr_accessor :host

    # When the check was last run (RFC3339 format)
    attr_accessor :last_tested_at

    # The server location the check will run next
    attr_accessor :next_location

    # Whether the check should be run
    attr_accessor :paused

    # Destination port for TCP checks
    attr_accessor :port

    # JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb
    attr_accessor :_post_body

    # Raw HTTP POST string to send to the server
    attr_accessor :post_raw

    # Whether the check is currently being processed
    attr_accessor :processing

    # The server location the check is currently being run
    attr_accessor :processing_on

    attr_accessor :processing_state

    # List of assigned monitoring locations on which to run checks
    attr_accessor :servers

    attr_accessor :status

    # List of status codes that trigger an alert
    attr_accessor :status_codes

    # List of tags
    attr_accessor :tags

    # The number of seconds to wait to receive the first byte
    attr_accessor :timeout

    # The number of minutes to wait before sending an alert
    attr_accessor :trigger_rate

    # Uptime percentage for a check
    attr_accessor :uptime

    # Whether to enable cookie storage
    attr_accessor :use_jar

    # Custom user agent string set when testing
    attr_accessor :user_agent

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'id' => :'id',
        :'name' => :'name',
        :'test_type' => :'test_type',
        :'website_url' => :'website_url',
        :'check_rate' => :'check_rate',
        :'confirmation' => :'confirmation',
        :'contact_groups' => :'contact_groups',
        :'custom_header' => :'custom_header',
        :'dns_ips' => :'dns_ips',
        :'dns_server' => :'dns_server',
        :'do_not_find' => :'do_not_find',
        :'enable_ssl_alert' => :'enable_ssl_alert',
        :'final_endpoint' => :'final_endpoint',
        :'find_string' => :'find_string',
        :'follow_redirects' => :'follow_redirects',
        :'include_header' => :'include_header',
        :'host' => :'host',
        :'last_tested_at' => :'last_tested_at',
        :'next_location' => :'next_location',
        :'paused' => :'paused',
        :'port' => :'port',
        :'_post_body' => :'post_body',
        :'post_raw' => :'post_raw',
        :'processing' => :'processing',
        :'processing_on' => :'processing_on',
        :'processing_state' => :'processing_state',
        :'servers' => :'servers',
        :'status' => :'status',
        :'status_codes' => :'status_codes',
        :'tags' => :'tags',
        :'timeout' => :'timeout',
        :'trigger_rate' => :'trigger_rate',
        :'uptime' => :'uptime',
        :'use_jar' => :'use_jar',
        :'user_agent' => :'user_agent',
      }
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'id' => :'String',
        :'name' => :'String',
        :'test_type' => :'UptimeTestType',
        :'website_url' => :'String',
        :'check_rate' => :'UptimeTestCheckRate',
        :'confirmation' => :'Integer',
        :'contact_groups' => :'Array<String>',
        :'custom_header' => :'String',
        :'dns_ips' => :'Array<String>',
        :'dns_server' => :'String',
        :'do_not_find' => :'Boolean',
        :'enable_ssl_alert' => :'Boolean',
        :'final_endpoint' => :'String',
        :'find_string' => :'String',
        :'follow_redirects' => :'Boolean',
        :'include_header' => :'Boolean',
        :'host' => :'String',
        :'last_tested_at' => :'Time',
        :'next_location' => :'String',
        :'paused' => :'Boolean',
        :'port' => :'Integer',
        :'_post_body' => :'String',
        :'post_raw' => :'String',
        :'processing' => :'Boolean',
        :'processing_on' => :'String',
        :'processing_state' => :'UptimeTestProcessingState',
        :'servers' => :'Array<MonitoringLocation>',
        :'status' => :'UptimeTestStatus',
        :'status_codes' => :'Array<String>',
        :'tags' => :'Array<String>',
        :'timeout' => :'Integer',
        :'trigger_rate' => :'Integer',
        :'uptime' => :'Float',
        :'use_jar' => :'Boolean',
        :'user_agent' => :'String',
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      unless attributes.is_a?(Hash)
        raise ArgumentError, "The input argument (attributes) must be a hash in `StatusCake::UptimeTest` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        unless self.class.attribute_map.key?(k.to_sym)
          raise ArgumentError, "`#{k}` is not a valid attribute in `StatusCake::UptimeTest`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.key?(:'name')
        self.name = attributes[:'name']
      end

      if attributes.key?(:'test_type')
        self.test_type = attributes[:'test_type']
      end

      if attributes.key?(:'website_url')
        self.website_url = attributes[:'website_url']
      end

      if attributes.key?(:'check_rate')
        self.check_rate = attributes[:'check_rate']
      end

      if attributes.key?(:'confirmation')
        self.confirmation = attributes[:'confirmation']
      end

      if attributes.key?(:'contact_groups')
        if (value = attributes[:'contact_groups']).is_a?(Array)
          self.contact_groups = value
        end
      end

      if attributes.key?(:'custom_header')
        self.custom_header = attributes[:'custom_header']
      end

      if attributes.key?(:'dns_ips')
        if (value = attributes[:'dns_ips']).is_a?(Array)
          self.dns_ips = value
        end
      end

      if attributes.key?(:'dns_server')
        self.dns_server = attributes[:'dns_server']
      end

      if attributes.key?(:'do_not_find')
        self.do_not_find = attributes[:'do_not_find']
      end

      if attributes.key?(:'enable_ssl_alert')
        self.enable_ssl_alert = attributes[:'enable_ssl_alert']
      end

      if attributes.key?(:'final_endpoint')
        self.final_endpoint = attributes[:'final_endpoint']
      end

      if attributes.key?(:'find_string')
        self.find_string = attributes[:'find_string']
      end

      if attributes.key?(:'follow_redirects')
        self.follow_redirects = attributes[:'follow_redirects']
      end

      if attributes.key?(:'include_header')
        self.include_header = attributes[:'include_header']
      end

      if attributes.key?(:'host')
        self.host = attributes[:'host']
      end

      if attributes.key?(:'last_tested_at')
        self.last_tested_at = attributes[:'last_tested_at']
      end

      if attributes.key?(:'next_location')
        self.next_location = attributes[:'next_location']
      end

      if attributes.key?(:'paused')
        self.paused = attributes[:'paused']
      end

      if attributes.key?(:'port')
        self.port = attributes[:'port']
      end

      if attributes.key?(:'_post_body')
        self._post_body = attributes[:'_post_body']
      end

      if attributes.key?(:'post_raw')
        self.post_raw = attributes[:'post_raw']
      end

      if attributes.key?(:'processing')
        self.processing = attributes[:'processing']
      end

      if attributes.key?(:'processing_on')
        self.processing_on = attributes[:'processing_on']
      end

      if attributes.key?(:'processing_state')
        self.processing_state = attributes[:'processing_state']
      end

      if attributes.key?(:'servers')
        if (value = attributes[:'servers']).is_a?(Array)
          self.servers = value
        end
      end

      if attributes.key?(:'status')
        self.status = attributes[:'status']
      end

      if attributes.key?(:'status_codes')
        if (value = attributes[:'status_codes']).is_a?(Array)
          self.status_codes = value
        end
      end

      if attributes.key?(:'tags')
        if (value = attributes[:'tags']).is_a?(Array)
          self.tags = value
        end
      end

      if attributes.key?(:'timeout')
        self.timeout = attributes[:'timeout']
      end

      if attributes.key?(:'trigger_rate')
        self.trigger_rate = attributes[:'trigger_rate']
      end

      if attributes.key?(:'uptime')
        self.uptime = attributes[:'uptime']
      end

      if attributes.key?(:'use_jar')
        self.use_jar = attributes[:'use_jar']
      end

      if attributes.key?(:'user_agent')
        self.user_agent = attributes[:'user_agent']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = []
      if @id.nil?
        invalid_properties.push('invalid value for "id", id cannot be nil.')
      end

      if @name.nil?
        invalid_properties.push('invalid value for "name", name cannot be nil.')
      end

      if @test_type.nil?
        invalid_properties.push('invalid value for "test_type", test_type cannot be nil.')
      end

      if @website_url.nil?
        invalid_properties.push('invalid value for "website_url", website_url cannot be nil.')
      end

      if @check_rate.nil?
        invalid_properties.push('invalid value for "check_rate", check_rate cannot be nil.')
      end

      if @confirmation.nil?
        invalid_properties.push('invalid value for "confirmation", confirmation cannot be nil.')
      end

      if @confirmation > 3
        invalid_properties.push('invalid value for "confirmation", must be smaller than or equal to 3.')
      end

      if @confirmation < 0
        invalid_properties.push('invalid value for "confirmation", must be greater than or equal to 0.')
      end

      if @contact_groups.nil?
        invalid_properties.push('invalid value for "contact_groups", contact_groups cannot be nil.')
      end

      if @dns_ips.nil?
        invalid_properties.push('invalid value for "dns_ips", dns_ips cannot be nil.')
      end

      if @do_not_find.nil?
        invalid_properties.push('invalid value for "do_not_find", do_not_find cannot be nil.')
      end

      if @enable_ssl_alert.nil?
        invalid_properties.push('invalid value for "enable_ssl_alert", enable_ssl_alert cannot be nil.')
      end

      if @follow_redirects.nil?
        invalid_properties.push('invalid value for "follow_redirects", follow_redirects cannot be nil.')
      end

      if @include_header.nil?
        invalid_properties.push('invalid value for "include_header", include_header cannot be nil.')
      end

      if @paused.nil?
        invalid_properties.push('invalid value for "paused", paused cannot be nil.')
      end

      if !@port.nil? && @port < 0
        invalid_properties.push('invalid value for "port", must be greater than or equal to 0.')
      end

      if @processing.nil?
        invalid_properties.push('invalid value for "processing", processing cannot be nil.')
      end

      if @servers.nil?
        invalid_properties.push('invalid value for "servers", servers cannot be nil.')
      end

      if @status.nil?
        invalid_properties.push('invalid value for "status", status cannot be nil.')
      end

      if @status_codes.nil?
        invalid_properties.push('invalid value for "status_codes", status_codes cannot be nil.')
      end

      if @tags.nil?
        invalid_properties.push('invalid value for "tags", tags cannot be nil.')
      end

      if @timeout.nil?
        invalid_properties.push('invalid value for "timeout", timeout cannot be nil.')
      end

      if @timeout > 75
        invalid_properties.push('invalid value for "timeout", must be smaller than or equal to 75.')
      end

      if @timeout < 5
        invalid_properties.push('invalid value for "timeout", must be greater than or equal to 5.')
      end

      if @trigger_rate.nil?
        invalid_properties.push('invalid value for "trigger_rate", trigger_rate cannot be nil.')
      end

      if @trigger_rate > 60
        invalid_properties.push('invalid value for "trigger_rate", must be smaller than or equal to 60.')
      end

      if @trigger_rate < 0
        invalid_properties.push('invalid value for "trigger_rate", must be greater than or equal to 0.')
      end

      if @uptime.nil?
        invalid_properties.push('invalid value for "uptime", uptime cannot be nil.')
      end

      if @uptime < 0
        invalid_properties.push('invalid value for "uptime", must be greater than or equal to 0.')
      end

      if @use_jar.nil?
        invalid_properties.push('invalid value for "use_jar", use_jar cannot be nil.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @id.nil?
      return false if @name.nil?
      return false if @test_type.nil?
      return false if @website_url.nil?
      return false if @check_rate.nil?
      return false if @confirmation.nil?
      return false if @confirmation > 3
      return false if @confirmation < 0
      return false if @contact_groups.nil?
      return false if @dns_ips.nil?
      return false if @do_not_find.nil?
      return false if @enable_ssl_alert.nil?
      return false if @follow_redirects.nil?
      return false if @include_header.nil?
      return false if @paused.nil?
      return false if !@port.nil? && @port < 0
      return false if @processing.nil?
      return false if @servers.nil?
      return false if @status.nil?
      return false if @status_codes.nil?
      return false if @tags.nil?
      return false if @timeout.nil?
      return false if @timeout > 75
      return false if @timeout < 5
      return false if @trigger_rate.nil?
      return false if @trigger_rate > 60
      return false if @trigger_rate < 0
      return false if @uptime.nil?
      return false if @uptime < 0
      return false if @use_jar.nil?
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] confirmation Value to be assigned
    def confirmation=(confirmation)
      if confirmation.nil?
        raise ArgumentError, 'confirmation cannot be nil'
      end

      if confirmation > 3
        raise ArgumentError, 'invalid value for "confirmation", must be smaller than or equal to 3.'
      end

      if confirmation < 0
        raise ArgumentError, 'invalid value for "confirmation", must be greater than or equal to 0.'
      end

      @confirmation = confirmation
    end

    # Custom attribute writer method with validation
    # @param [Object] port Value to be assigned
    def port=(port)
      if !port.nil? && port < 0
        raise ArgumentError, 'invalid value for "port", must be greater than or equal to 0.'
      end

      @port = port
    end

    # Custom attribute writer method with validation
    # @param [Object] timeout Value to be assigned
    def timeout=(timeout)
      if timeout.nil?
        raise ArgumentError, 'timeout cannot be nil'
      end

      if timeout > 75
        raise ArgumentError, 'invalid value for "timeout", must be smaller than or equal to 75.'
      end

      if timeout < 5
        raise ArgumentError, 'invalid value for "timeout", must be greater than or equal to 5.'
      end

      @timeout = timeout
    end

    # Custom attribute writer method with validation
    # @param [Object] trigger_rate Value to be assigned
    def trigger_rate=(trigger_rate)
      if trigger_rate.nil?
        raise ArgumentError, 'trigger_rate cannot be nil'
      end

      if trigger_rate > 60
        raise ArgumentError, 'invalid value for "trigger_rate", must be smaller than or equal to 60.'
      end

      if trigger_rate < 0
        raise ArgumentError, 'invalid value for "trigger_rate", must be greater than or equal to 0.'
      end

      @trigger_rate = trigger_rate
    end

    # Custom attribute writer method with validation
    # @param [Object] uptime Value to be assigned
    def uptime=(uptime)
      if uptime.nil?
        raise ArgumentError, 'uptime cannot be nil'
      end

      if uptime < 0
        raise ArgumentError, 'invalid value for "uptime", must be greater than or equal to 0.'
      end

      @uptime = uptime
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if equal?(other)
      self.class == other.class &&
        id == other.id &&
        name == other.name &&
        test_type == other.test_type &&
        website_url == other.website_url &&
        check_rate == other.check_rate &&
        confirmation == other.confirmation &&
        contact_groups == other.contact_groups &&
        custom_header == other.custom_header &&
        dns_ips == other.dns_ips &&
        dns_server == other.dns_server &&
        do_not_find == other.do_not_find &&
        enable_ssl_alert == other.enable_ssl_alert &&
        final_endpoint == other.final_endpoint &&
        find_string == other.find_string &&
        follow_redirects == other.follow_redirects &&
        include_header == other.include_header &&
        host == other.host &&
        last_tested_at == other.last_tested_at &&
        next_location == other.next_location &&
        paused == other.paused &&
        port == other.port &&
        _post_body == other._post_body &&
        post_raw == other.post_raw &&
        processing == other.processing &&
        processing_on == other.processing_on &&
        processing_state == other.processing_state &&
        servers == other.servers &&
        status == other.status &&
        status_codes == other.status_codes &&
        tags == other.tags &&
        timeout == other.timeout &&
        trigger_rate == other.trigger_rate &&
        uptime == other.uptime &&
        use_jar == other.use_jar &&
        user_agent == other.user_agent
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [id, name, test_type, website_url, check_rate, confirmation, contact_groups, custom_header, dns_ips, dns_server, do_not_find, enable_ssl_alert, final_endpoint, find_string, follow_redirects, include_header, host, last_tested_at, next_location, paused, port, _post_body, post_raw, processing, processing_on, processing_state, servers, status, status_codes, tags, timeout, trigger_rate, uptime, use_jar, user_agent].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      attributes = attributes.transform_keys(&:to_sym)
      self.class.openapi_types.each_pair do |key, type|
        if attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)
          send("#{key}=", nil)
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize(Regexp.last_match(1), v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = StatusCake.const_get(type)
        klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
